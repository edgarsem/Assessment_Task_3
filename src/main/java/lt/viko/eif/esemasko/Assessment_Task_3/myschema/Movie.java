//
// This file was generated by the Eclipse Implementation of JAXB, v3.0.0 
// See https://eclipse-ee4j.github.io/jaxb-ri 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2023.04.28 at 07:39:20 PM EEST 
//


package lt.viko.eif.esemasko.Assessment_Task_3.myschema;

import jakarta.persistence.*;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;


/**
 * <p>Java class for movie complex type.
 *
 * <p>The following schema fragment specifies the expected content contained within this class.
 *
 * <pre>
 * &lt;complexType name="movie"&gt;
 *   &lt;complexContent&gt;
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *       &lt;sequence&gt;
 *         &lt;element name="id" type="{http://www.w3.org/2001/XMLSchema}byte"/&gt;
 *         &lt;element name="title" type="{http://www.w3.org/2001/XMLSchema}string"/&gt;
 *         &lt;element name="length" type="{http://www.w3.org/2001/XMLSchema}short"/&gt;
 *         &lt;element name="genres" type="{http://spring.io/guides/gs-producing-web-service}genre" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="directors" type="{http://spring.io/guides/gs-producing-web-service}director" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="writers" type="{http://spring.io/guides/gs-producing-web-service}writer" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="cast" type="{http://spring.io/guides/gs-producing-web-service}actor" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="reviews" type="{http://spring.io/guides/gs-producing-web-service}movieReview" maxOccurs="unbounded" minOccurs="0"/&gt;
 *       &lt;/sequence&gt;
 *     &lt;/restriction&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 */
@Entity
public class Movie {

    private @Id
    @GeneratedValue Long id;

    protected String title;

    protected short length;

    @ManyToMany(cascade = CascadeType.ALL)
    @JoinTable(name = "movie_genre",
            joinColumns = @JoinColumn(name = "movie_id", referencedColumnName = "id"),
            inverseJoinColumns = @JoinColumn(name = "genre_id", referencedColumnName = "id"))
    protected List<Genre> genres;

    @ManyToMany(cascade = CascadeType.ALL)
    @JoinTable(name = "movie_director",
            joinColumns = @JoinColumn(name = "movie_id", referencedColumnName = "id"),
            inverseJoinColumns = @JoinColumn(name = "director_id", referencedColumnName = "id"))

    protected List<Director> directors;

    @ManyToMany(cascade = CascadeType.ALL)
    @JoinTable(name = "movie_writer",
            joinColumns = @JoinColumn(name = "movie_id", referencedColumnName = "id"),
            inverseJoinColumns = @JoinColumn(name = "writer_id", referencedColumnName = "id"))
    protected List<Writer> writers;

    @ManyToMany(cascade = CascadeType.ALL)
    @JoinTable(name = "movie_actor",
            joinColumns = @JoinColumn(name = "movie_id", referencedColumnName = "id"),
            inverseJoinColumns = @JoinColumn(name = "actor_id", referencedColumnName = "id"))
    protected List<Actor> cast;

    @ManyToMany(cascade = CascadeType.ALL)
    @JoinTable(name = "movie_moviereview",
            joinColumns = @JoinColumn(name = "movie_id", referencedColumnName = "id"),
            inverseJoinColumns = @JoinColumn(name = "moviereview_id", referencedColumnName = "id"))
    protected List<MovieReview> reviews;


    /**
     * Gets the value of the id property.
     */
    public Long getId() {
        return id;
    }

    /**
     * Sets the value of the id property.
     */
    public void setId(Long value) {
        this.id = value;
    }

    /**
     * Gets the value of the title property.
     *
     * @return possible object is
     * {@link String }
     */
    public String getTitle() {
        return title;
    }

    /**
     * Sets the value of the title property.
     *
     * @param value allowed object is
     *              {@link String }
     */
    public void setTitle(String value) {
        this.title = value;
    }

    /**
     * Gets the value of the length property.
     */
    public short getLength() {
        return length;
    }

    /**
     * Sets the value of the length property.
     */
    public void setLength(short value) {
        this.length = value;
    }

    /**
     * Gets the value of the genres property.
     *
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the genres property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getGenres().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Genre }
     */
    public List<Genre> getGenres() {
        if (genres == null) {
            genres = new ArrayList<Genre>();
        }
        return this.genres;
    }

    /**
     * Gets the value of the directors property.
     *
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the directors property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDirectors().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Director }
     */
    public List<Director> getDirectors() {
        if (directors == null) {
            directors = new ArrayList<Director>();
        }
        return this.directors;
    }

    /**
     * Gets the value of the writers property.
     *
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the writers property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getWriters().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Writer }
     */
    public List<Writer> getWriters() {
        if (writers == null) {
            writers = new ArrayList<Writer>();
        }
        return this.writers;
    }

    /**
     * Gets the value of the cast property.
     *
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the cast property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCast().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Actor }
     */
    public List<Actor> getCast() {
        if (cast == null) {
            cast = new ArrayList<Actor>();
        }
        return this.cast;
    }

    /**
     * Gets the value of the reviews property.
     *
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the reviews property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getReviews().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link MovieReview }
     */
    public List<MovieReview> getReviews() {
        if (reviews == null) {
            reviews = new ArrayList<MovieReview>();
        }
        return this.reviews;
    }

    /**
     * Indicates whether some other object is "equal to" this one.
     * The equals method implements an equivalence relation on non-null object references.
     *
     * @param o the reference object with which to compare
     * @return true if this object is the same as the object argument; false otherwise
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Movie movie = (Movie) o;
        return length == movie.length && Objects.equals(id, movie.id) && Objects.equals(title, movie.title) && Objects.equals(genres, movie.genres) && Objects.equals(directors, movie.directors) && Objects.equals(writers, movie.writers) && Objects.equals(cast, movie.cast) && Objects.equals(reviews, movie.reviews);
    }

    /**
     * Returns a hash code value for the object.
     * This method is supported for the benefit of hash tables such as those provided by java.util.HashMap.
     *
     * @return a hash code value for this object
     */
    @Override
    public int hashCode() {
        return Objects.hash(id, title, length, genres, directors, writers, cast, reviews);
    }

    /**
     * Returns a string representation of the object.
     *
     * @return a string representation of the object
     */
    @Override
    public String toString() {
        return "Movie{" +
                "id=" + id +
                ", title='" + title + '\'' +
                ", length=" + length +
                ", genres=" + genres +
                ", directors=" + directors +
                ", writers=" + writers +
                ", cast=" + cast +
                ", reviews=" + reviews +
                '}';
    }
}
